Evaluation function f(n) = h(n)
h(n): heuristic function
h(n): estimated cost of the cheapest path from node n to goal node.
If n is goal then h(n)=0
Greedy best-first search expands the node that appears to be closest to goal
Example: hSLD(n) = straight-line distance from n to Bucharest
General approach of informed search:
Best-first search: node is selected for expansion based on an evaluation function f(n)
Evaluation function: estimate of desirability
Usually is an estimated cost or distance 
Choose node which appears best
Implementation:
fringe is queue sorted in decreasing order of desirability.
Special cases: greedy search, A* search
function TREE-SEARCH(problem,fringe) return a solution or failurefringe  INSERT(
MAKE-NODE(INITIAL-STATE[problem]), fringe)loop doif EMPTY?(fringe) then return failurenode  REMOVE-FIRST(fringe)
if GOAL-TEST[problem] applied to STATE[node] succeedsthen return SOLUTION(node)
fringe  INSERT-ALL(EXPAND(node, problem), fringe)
Recall that the ordering of fringe defines the search strategy
Best-known form of best-first search.
Idea: avoid expanding paths that are already expensive.
Evaluation function f(n)=g(n) + h(n)
g(n) the cost (so far) to reach the node.
h(n) estimated cost to get from the node to the goal.
f(n) estimated total cost of path through n to goal. 
A heuristic h(n) is admissible if for every node n,    h(n) ≤ h*(n), where h*(n) is the true cost to reach the goal state from n.
An admissible heuristic never overestimates the cost to reach the goal, i.e., it is optimistic
Example: hSLD(n) (never overestimates the actual road distance)
Theorem: If h(n) is admissible, A* using TREE-SEARCH is optimalhey there i fucking hate working with files
Games are a form of multi-agent environment
Competitive multi-agent environments give rise to adversarial search a.k.a. games
Games vs. Search Problems
"Unpredictable" opponent  specifying a move for every possible opponent reply
Time limits  unlikely to find goal, must approximate
Two players: MAX and MIN
MAX moves first and they take turns until the game is over. Winner gets award, looser gets penalty.
Zero-sum game: sum of scores is zero.
The environment is deterministic, fully observable
Games as search:
Initial state: e.g. board configuration of chess
Successor function: list of (move,state) pairs specifying legal moves.
Terminal test: Is the game finished?
Utility function: Gives numerical value of terminal states. E.g. win (+1), loose (-1) and draw (0) in tic-tac-toe (next)
MAX uses  search tree to determine next move.
Definition of optimal play for MAX assumes MIN plays optimally: maximizes worst-case outcome for MAX.
But if MIN does not play optimally, MAX will do even better.  [proven.]
Assumption: Both players play optimally !!
Given a game tree, the optimal strategy can be determined by using the minimax value of each node:

	MINIMAX-VALUE(n)=
		UTILITY(n)				If n is a terminal
		maxs  successors(n) MINIMAX-VALUE(s) 	If n is a max node
		mins  successors(n) MINIMAX-VALUE(s) 	If n is a min node
Change:
if TERMINAL-TEST(state) then return UTILITY(state)
	into
if CUTOFF-TEST(state,depth) then return EVAL(state)

Introduces a fixed-depth limit depth
Is selected so that the amount of time will not exceed what the rules of the game allow.

When cuttoff occurs, the evaluation is performed.
Quiescence search: further search for non-quiescent (wild swings in value in near future) states

Idea: produce an estimate of the expected utility of the game from a given position.
Performance depends on quality of EVAL.
Requirements:
EVAL should order terminal-nodes in the same way as UTILITY.
Computation may not take too long.
For non-terminal states the EVAL should be strongly correlated with the actual chance of winning.
Remove branches that do not influence final decision
Uses two important parameters
Alpha (α): The alpha value of a MAX node is a lower bound on the final backed-up value. It can never decrease
Beta (β): The beta value of a MIN node is an upper bound on the final backed-up value. It can never increa
"""
Django settings for loginAPI project.

Generated by 'django-admin startproject' using Django 4.0.3.

For more information on this file, see
https://docs.djangoproject.com/en/4.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.0/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-s=iokk55o@ccd25w9ia=o_-9xo2fthe=)agv#^*a8+5(mhnreq'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'accounts',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'loginAPI.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'loginAPI.wsgi.application'


# Database
# https://docs.djangoproject.com/en/4.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/4.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    # {
    #     'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    # },
    # {
    #     'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    # },
    # {
    #     'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    # },
]


# Internationalization
# https://docs.djangoproject.com/en/4.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.0/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/4.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
"""loginAPI URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/4.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('accounts.api.urls')),
]


from django.db import models
from django.db.models.deletion import CASCADE
from django.db.models.fields import CharField, TextField, DateField,DateTimeField
from django.db.models.fields.files import ImageField
from django.db.models.fields.related import ForeignKey
from accounts.models import UserProfile



class Post(models.Model):
    author = ForeignKey(UserProfile, on_delete=CASCADE, related_name='posts')
    image = ImageField(default="default-avatar-image.png", upload_to="uploads", blank=False)
    caption = TextField(blank=True)
    post_date = models.DateTimeField(auto_now=False, auto_now_add=True)



class Like(models.Model):
    post = ForeignKey(Post, on_delete=CASCADE, related_name='post_likes')
    user = ForeignKey(UserProfile, on_delete=CASCADE, related_name='like_user')
    create_date = DateField(auto_now=False, auto_now_add=True)


class Friends(models.Model):
	to_user = ForeignKey(UserProfile, related_name='to_user', on_delete=models.CASCADE)
	from_user = ForeignKey(UserProfile, related_name='from_user', on_delete=models.CASCADE)
	create_date = DateField(auto_now=False, auto_now_add=True)

        
from django.shortcuts import get_object_or_404, render
from .models import Like, Post, Friends
from accounts.models import UserProfile, UserLogins
from .forms import NewPostForm
from django.http.response import HttpResponseRedirect



class UserModel():
    def __init__(self, id,  username, following, profile):
        self.id = id 
        self.username = username
        self.following = following
        self.profile = profile

class PostModel():
    def __init__(self, user, post, likes):
        self.user = user 
        self.post = post
        self.likes = likes
    
    def __str__(self):
        return self.user.username


def users_likes(post):

    users = []

    likes = post.post_likes.all()
    for like in likes:
        users.append(like.user)
    return users


def myposts_page(request):
    
    
    user_posts = request.user.posts.all().order_by('post_date')
    followers = request.user.to_user.all()
    followings = request.user.from_user.all()
    



    posts = []

    for post in user_posts:
        likes = users_likes(post)
        posts.append(PostModel(request.user, post, likes))

    

    return render(request, 'data/mypage.html' , {
        'id' : request.user.id,
        'avatar' : request.user.avatar_image,
        'profile' : request.user.profile_image,
        'name' : request.user.name,
        'username' : request.user.username,
        'bio' : request.user.bio,
        'posts' : posts,
        'followers' : followers,
        'followings' : followings,
        'is_allowed' : True
    })


def allposts_page(request):
    # find all users friends and show their posts

    posts = []

    friends = Friends.objects.filter(from_user=request.user)

    for friend in friends:
        f_posts = Post.objects.filter(author=friend.to_user)
        for post in f_posts:
            likes = users_likes(post)
            model = PostModel(friend.to_user, post, likes)
            posts.append(model)

    


    return render(request, 'data/allposts.html' , {
        'posts' : posts
    })


def profile_page(request, id):

    user = UserProfile.objects.get(id=id)
    user_posts = Post.objects.all().filter(author=user)
    followers = Friends.objects.all().filter(to_user=user)
    followings = Friends.objects.all().filter(from_user=user)
    
    posts = []
    for post in user_posts:
        likes = users_likes(post)
        model = PostModel(user, post, likes)
        posts.append(model)
    

    return render(request, 'data/user-posts.html' , {
        'id' : user.id,
        'avatar' : user.avatar_image,
        'profile' : user.profile_image,
        'name' : user.name,
        'username' : user.username,
        'bio' : user.bio,
        'posts' : posts,
        'followers' : len(followers),
        'followings' : len(followings),
        'is_allowed' : False
    })


def is_following(current_user, user):
    # check if current user follows user
    # check if is a friend ship with to_user = user and from_user = current_user
    result = Friends.objects.filter(to_user=user, from_user=current_user)
    if result :
        return True
    else:
        return False


def followers_page(request):


    followers = request.user.to_user.all()


    profiles = []
    
    
    for friendship in followers:
        check = is_following(request.user, friendship.from_user)
        profiles.append(UserModel(friendship.from_user.id, friendship.from_user.username, 
        check, friendship.from_user.profile_image))

    matching = profiles
    

    if request.method == 'POST':
        searched = request.POST['searched']
        matching = [x for x in profiles if searched in x.username]


    return render(request, 'data/users-list.html', {
        'page_name' : 'followers',
        'users' : matching
    }) 


def followings_page(request):
    

    followers = Friends.objects.all().filter(from_user=request.user)

    profiles = []
    
    
    for friendship in followers:
        profiles.append(UserModel(friendship.to_user.id,
        friendship.to_user.username, True,
        friendship.to_user.profile_image))
    
    matching = profiles

    if request.method == 'POST':
        searched = request.POST['searched']

        matching = [x for x in profiles if searched in x.username]





    return render(request, 'data/users-list.html', {
        'page_name' : 'followings',
        'users' : matching
    }) 


def find_followings(users, friends):
        result = []
        for user in users:
            check = [f for f in friends if f.to_user == user]
            if check: 
                result.append(UserModel(user.id, user.username, True, user.profile_image))
            else:
                result.append(UserModel(user.id, user.username, False, user.profile_image))
                
        return result
    

def search_all_users(request):
    if request.method == 'POST':
        searched = request.POST['searched']
        users = UserProfile.objects.filter(username__contains=searched).exclude(id=request.user.id)
        friends = Friends.objects.filter(from_user=request.user)


        result = find_followings(users, friends)

            

        return render(request, 'data/users-list.html', {
            'page_name' : 'all-users',
            'users' : result
        })


def requests(request):
    #use get object or 404 :
    # if exist : wants to unfollow
    # if not : wants to follow 

    selected_user = UserProfile.objects.get(id=request.POST['user-id'])

    try:
        friendships = Friends.objects.all().filter(from_user=request.user)
        friendship = get_object_or_404(friendships, to_user=selected_user)
        friendship.delete()
    except:
        friendship = Friends(to_user=selected_user, from_user=request.user)
        friendship.save()
        
    # users = UserProfile.objects.all()
    # result = find_followings(users, friendships)

    return render(request, 'data/users-list.html')


def create_post(request):
    if request.method == 'POST':
        post_form = NewPostForm(request.POST, request.FILES)
        if post_form.is_valid():
            print(request.FILES)
            post = post_form.save(commit=False)
            post.author = request.user
            post.save()
        else:
            print('invalid form')
    else:
        post_form = NewPostForm()

    return render(request, 'data/create-post.html', {
        'form' : post_form
    })


def like_post(request):

    post = request.POST['post']
    post_object = Post.objects.get(id=int(post))
  
    like = Like.objects.all().filter(user=request.user, post=post_object)
    if like:
        like.delete()
    else:
        like = Like(post=post_object, user=request.user)
        like.save()
            

    return HttpResponseRedirect('/data/allposts')


def user_likes_page(request, id):
    post = Post.objects.get(id=id)
    likes = users_likes(post)
    
    friends = Friends.objects.filter(from_user=request.user)


    result = find_followings(likes, friends)
    
    
    return render(request, 'data/users-list.html', {
        'users' : result
    })


from django.urls import path
from . import views

urlpatterns = [
    path('myposts', views.myposts_page, name='myposts'),
    path('allposts', views.allposts_page, name="allposts"),
    path('profiles/<int:id>', views.profile_page, name='profiles'),
    path('followers', views.followers_page, name='followers-page'),
    path('followings', views.followings_page, name='followings-page'),
    path('search-users',views.search_all_users, name='search-users' ),
    path('requests', views.requests),
    path('create-post', views.create_post, name='create-post'),
    path('like-post', views.like_post, name='like-post'),
    path('user-likes/<int:id>', views.user_likes_page, name='user-likes'),
]
from django.contrib import admin
from django.db.models import fields
from data.models import Post, Friends, Like
# Register your models here.


class PostsAdmin(admin.ModelAdmin):
    list_display = [field.name for field in Post._meta.get_fields()]

class LikesAdmin(admin.ModelAdmin):
    list_display = [field.name for field in Like._meta.get_fields()]

class FriendsAdmin(admin.ModelAdmin):
    list_display = [field.name for field in Friends._meta.get_fields()]




admin.site.register(Post, PostsAdmin)
admin.site.register(Like, LikesAdmin)
admin.site.register(Friends, FriendsAdmin)


"""socialmedia URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/3.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include
from django.conf.urls.static import static
from django.conf import settings



urlpatterns = [
    path('admin/', admin.site.urls),
    path('account/', include('accounts.urls')),
    path('data/', include('data.urls'))
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
import re
from django.core.exceptions import ValidationError
from django.utils.translation import ugettext as _
from django.contrib.auth.password_validation import CommonPasswordValidator


class CommonPassValidator(CommonPasswordValidator):
    def validate(self, password, user=None):
        if password.lower().strip() in self.passwords:
            raise ValidationError(
                _('پسورد وارد شده خیلی ساده است.')
            )
    
    def get_help_text(self):
        return _('پسورد وارد شده خیلی ساده است.')


class MinimumLengthValidator(object):
    def validate(self, password, user=None):
        if len(password) < 6:
            raise ValidationError(
                _('پسورد باید حداقل 6 کاراکتر داشته باشد.')
            )
    
    def get_help_text(self):
        return _('پسورد باید حداقل 6 کاراکتر داشته باشد.')


class HasNumberValidator(object):
    def validate(self, password, user=None):
        if not re.findall('\d', password):
            raise ValidationError(
                _('پسورد باید حداقل شامل یک عدد باشد.')
            )

    def get_help_text(self):
        return _('پسورد باید حداقل شامل یک عدد باشد.')


class HasUppercase(object):
    def validate(self, password, user=None):
        if not re.findall('[A-Z]', password):
            raise ValidationError(
                _('پسورد باید حداقل یک حرف بزرگ داشته باشد.')
            )

    def get_help_text(self):
        return _('پسورد باید حداقل یک حرف بزرگ داشته باشد.')


class HasLowercase(object):
    def validate(self, password, user=None):
        if not re.findall('[a-z]', password):
            raise ValidationError(
                _('پسورد باید حداقل یک حرف کوچک داشته باشد.')
            )

    def get_help_text(self):
        _('پسورد باید حداقل یک حرف کوچک داشته باشد.')

"""
WSGI config for socialmedia project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'socialmedia.settings')

application = get_wsgi_application()
"""
ASGI config for socialmedia project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'socialmedia.settings')

application = get_asgi_application()
import re 
from django.conf import settings 
from django.shortcuts import redirect



EXEMPT_URLS = [re.compile(settings.LOGIN_URL.lstrip('/'))]
if hasattr(settings, 'LOGIN_EXEMPT_URLS'):
    EXEMPT_URLS += [re.compile(url) for url in settings.LOGIN_EXEMPT_URLS]


class LoginRequiredMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response 
        
    def __call__(self, request):
        response = self.get_response(request)
        return response
    
    def process_view(self, request, view_func, view_args, view_kwargs):
        assert hasattr(request, 'user')
        path = request.path_info.lstrip('/')
        
        if not request.user.is_authenticated:
            if not any(url.match(path) for url in EXEMPT_URLS):
                return redirect(settings.LOGIN_URL)

"""
Django settings for socialmedia project.

Generated by 'django-admin startproject' using Django 3.2.9.

For more information on this file, see
https://docs.djangoproject.com/en/3.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/3.2/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/3.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-v6ezmfhes2u&h0l(h^etgo#mdhf!!t4ba=-k1x#^+w@4j^hq%@'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'accounts',
    'data',
    'django_extensions',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'socialmedia.middleware.LoginRequiredMiddleware'
]

ROOT_URLCONF = 'socialmedia.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            BASE_DIR / 'templates',
        ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'socialmedia.wsgi.application'


# Database
# https://docs.djangoproject.com/en/3.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/3.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [

    {
        'NAME': 'socialmedia.validators.CommonPassValidator',
    },
    {
        'NAME': 'socialmedia.validators.HasNumberValidator',
    },
    {
        'NAME': 'socialmedia.validators.HasUppercase',
    },
    {
        'NAME': 'socialmedia.validators.HasLowercase',
    },
    {
        'NAME': 'socialmedia.validators.MinimumLengthValidator',
    },
]



# Internationalization
# https://docs.djangoproject.com/en/3.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.2/howto/static-files/

STATIC_URL = '/static/'

# Default primary key field type
# https://docs.djangoproject.com/en/3.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


MEDIA_ROOT = BASE_DIR / "uploads"
MEDIA_URL = '/user-media/'

AUTH_USER_MODEL = 'accounts.UserProfile'

from django.contrib.messages import constants as messages
MESSAGES_TAGS = {
    messages.ERROR: 'danger',
}


LOGIN_REDIRECT_URL = 'data/allposts'

LOGIN_URL = '/account/login' 

LOGIN_EXEMPT_URLS = (
    'account/register'
)